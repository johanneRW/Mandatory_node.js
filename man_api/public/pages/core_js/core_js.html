<div class="container px-4 py-5" id="featured-3">
  <h2 class="pb-2 border-bottom">Core JS</h2>
  <p>Read more about core Javascript concepts such as functions, data types, loops and dates.</p>
  <br>
  <div>
    <h5>Datatypes</h5>
    JavaScript is a weakly-typed language, which means you don't declare a type when making a variable. <br>
    Data types are dynamic, meaning a variable can hold different types of data. <br>
    <br>
    <b>The data types are: </b>
    <ul>
      <li>String: you can use " " or ' ' to declare something as a string. (If you want to make a string template
        literal (${ }), you'll have to use ` ` instead.) </li>
      <li>Number: contains both floats and non-floats. </li>
      <li>Boolean </li>
      <li>Array </li>
      <li>Objects </li>
      <li>Undefined and null </li>
    </ul>
    In JavaScript, there are two comparison operators for checking equality: == (soft equality) and === (hard
    equality).<br>
    The difference between the two is how they perform type coercion when comparing values.<br>
    <br>
    Soft equality (==) compares two values for equality after converting their types if necessary. <br>
    For example, when comparing a string and a number, the string will be converted to a number before comparison. <br>
    This can sometimes lead to unexpected results.
    <pre>
<code>
    2 == "2" (true) 

    2 != “2” (false) 
  </code>
</pre>
    Hard equality (===) compares two values for equality without converting their types. <br>
    This means that both the value and type of the operands must match for the comparison to return true.<br>
    For instance, "2" === 2 would return false, since the operands are of different types.<br>
    <pre>
<code>
    2 === "2" (false) 

    2 !== "2" (true) 
  </code>
</pre>
    In general, it's a good practice to use hard equality (===) in JavaScript, as it ensures that values are compared
    without type coercion, which can help avoid bugs and unexpected behavior in your code.
  </div>
</div>
<br>
<div>
  <h5>Map/filter/find and loops</h5>
  There are different ways of creating loops in Javascript. There are classic “for” loops, but also specialized
  functions such as “map”, “filter” and “find”. <br>
  The old school “for” loop is considered verbose, ineffective and error prone.<br>
  It is easy to create a “for” loop which modifies the data it is working on, rather than creating a copy of the data
  with the desired changes. This can unexpectedly modify the original data. <br>
  The classic “for” loop is only used in situations where you normally would be counting up (as you would do with your
  fingers, counting how many times something is done.) <br>
  Instead you should usually use loop methods such as “map”, “filter” and “find”, which all return new data instead of
  modifying the original data. <br>
  <br>
  <li><b>map():</b> creates a new array with the results of calling a function for every array element. </li>
  Map() does not modify the original array.
  When using map it can be useful to use <b>the spread operater (...)</b> <br>
  the spread operator can be used to create a new array that includes the elements from the original array as well as
  additional elements. For example: <br>
  <pre>
    <code>
  const rocks = [ 
  { name: "Pet rock", age: 2 }, 
  { name: "Led Zeppelin", age: 55 }, 
  { name: "Dwayne Johnson", age: 50 }, 
  { name: "Granite", age: 100_000_000_000 } 
  ]; 
  
  const rocksAgedOneYear = rocks.map(rock => ({ ...rock, age: rock.age+1 })); 
  
  console.log(rocksAgedOneYear) 

  Output:
  [ 
    { name: 'Pet rock', age: 3 }, 
    { name: 'Led Zeppelin', age: 56 }, 
    { name: 'Dwayne Johnson', age: 51 }, 
    { name: 'Granite', age: 100000000001 } 
  ] 
</code>
</pre>
  <li><b>filter()</b> creates a new array with all array elements that matches a given condition. </li>
  It does not modify the original array.
  <pre>
    <code> 
  const numbers = [1, 3, 5, 2, 4]; 
  
  const evenNumbers = numbers.filter((number) => number % 2 === 0); 
  console.log(evenNumbers)
   
  Output:[2, 4] 
</code>
</pre>
  <li>The <b>find()</b> method returns the value of the first element in an array that matches a given condition. If
    more than one element matches it will be the first element that matches the conditions that is returned. </li>
  If no element satisfies the given condition, undefined is returned. <br>
  <pre>
    <code>
  const numbers = [1,2,3, 4]; 
   
  const firstEven = numbers.find((number) => { 
    return number % 2 === 0; 
  }); 
   
  console.log(firstEven)

  Output: 2
</code>
</pre>
</div>
<br>
<div>
  <h5>Arrays</h5>
  An array in javascript is a collection of either simple datatypes or objects.<br>
  Besides the loop methods (map/filter/find), there are multiple other methods to manipulate an array.<br>
  <ul>
    <li>.length(): returns the length of the array</li>
    <li>.pop(): removes the last element in an array and returns it</li>
    <li>.push(): adds one or more elements to the end of the array</li>
    <li>.shift(): removes the first element and "moves" all other elements forward in the array</li>
    <li>.splice(): used to add, remove, or replace elements at a specific index in the array)</li>
    <li>.splice() can be used in a couple of different ways. It is sometimes used to remove items (like .pop()), but it
      can
      also be used to add or replace items. The first parameter of “.splice()” refers to the index in the array, the
      second
      to how many items needs to be replaced, and the final parameter(s) are the new items to add or replace.
    </li>
    <pre>
    <code>
  const fruits = ['apple', 'banana', 'orange', 'peach'];

  fruits.splice(2, 0, 'grape', 'kiwi');

  console.log(fruits); 
  
  Output: ['apple', 'orange', 'grape', 'kiwi', 'peach']

  // replace two elements starting at index 1
  fruits.splice(1, 2, 'mango', 'papaya');

  console.log(fruits)
  
  Output: ['apple', 'mango', 'papaya', 'kiwi', 'peach']
</code>
</pre>
  </ul>
</div>
<br>
<div>
  <h5>Dates</h5>
  There are three important ways to create a date in Javascript: “Date”, “Date.now()”, and “new Date().getTime()”.<br>
  <ul>
    <li>
      “Date”: Is used to represent a specific time on a specific date. It can be created using parameters as year,
      month,
      day, hour, minute, second, and millisecond.</li>
    <li>“Date.now()”: This method returns the number of milliseconds elapsed since January 1, 1970, 00:00:00 UTC (also
      called
      Zulu time). It is often used to make timestamps.</li>
    <li>“new Date().getTime()”: This method also returns the number of milliseconds since January 1, 1970, 00:00:00 UTC.
      The
      main difference is that it creates a new Date object, and then returns its time value.</li>
  </ul>
  All date datatypes can be converted to eachother. All types of date datatypes have multiple methods to convert them to
  another value, such as getDay(), getDate(), getMonth(), getFullYear(), getHours(), getMinutes(), getSeconds().<br>
  <br>
  If you want to know the weekday of a given Date, you can call “getDay()”. You will get an index from 0-6 - you should
  know that in an array of weekdays, the weekdays start on a Sunday, as is normal in the US calendar.
  <pre>
    <code>
  Weekdays = [sunday, monday, tuesday, wednesday, thursday, friday, saturday]
</code>
</pre>
  The months run from January to December, where January = 0 and December = 11.
</div>
<br>
<div>
  <h5>Const, let and var</h5>
  There are three types of variables in JavaScript and the rule is:<br>
  <b>Use <i>const</i> if you can, <i>let</i> if you must, and never use <i>var.</i></b><br>
  <br>
  <b>const</b><br>
  const is used to declare a variable with a constant value.<br>
  Use const when declaring variables when you know their value will not change.<br><br>
  <b>let</b><br>
  Use let to declare variables when you know the value will change.<br>
  let is used to declare a variable that is only accessible within the block in which it is defined.<br><br>
  <b>var</b><br>
  We don't use var anymore.<br>
  Var is generally not used anymore because it creates a global variable, and var is not scope-dependent.<br>
  This means that using var can lead to unexpected behavior.
</div>
<br>
<div>
  <h5>Functions</h5>
  Functions in JavaScript are a way to isolate a block of code that performs a specific task. <br>
  Functions can be reused throughout a program to avoid duplicating code. This makes the code easier to read and
  maintain.<br>
  A function can be assigned to a variable or be passed as an argument to another function.<br>
  Functions are defined by the keyword "function" or by the arrow => (known as an <b>arrow function</b>).<br>
  JavaScript has some built-in functions, such as “console.log()”, that can be used to perform common tasks.<br>
  <br>
  Example function definitions:<br>
  <pre>
    <code>
  function random(min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
  }

  const randomAnonymousFunction = function (min, max) {
  return Math.floor(Math.random() * (max - min + 1) + min);
  };

  const randomArrowFunction = (min, max) => {
  return Math.floor(Math.random() * (max - min + 1) + min);
  };
</code>
</pre>
  Finally, we have <b>callback functions.</b><br>
  A callback function is a function that is passed as a parameter to another function.<br>
  It can be used to ensure that actions happen in the correct order. Callback functions can also be used for event
  handling, where a function is
  called when a certain event occurs, such as a user clicking a button or a page finishing loading. They can make our
  functions smaller and more reusable.<br>
  <br>
  Example of a callback function:<br>
  <pre>
    <code>
  function genericActionPerformer(genericAction, genericName) {
  // do stuff...
  return genericAction(genericName);
  }

  const subtract = (name) => `${name} is subtracting.`;
  console.log(genericActionPerformer(subtract, "aName"));

  const walk = (name) => `${name} is walking.`;
  console.log(genericActionPerformer(walk, "nameName"));
</code>
</pre>
</div>

<script type="module" src="../pages/core_js/core_js.js"></script>